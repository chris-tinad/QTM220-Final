---
title: "Predicting Song Danceability"
author: "Alix Morales, Christina Dai, Lola Pawar, Stan Xu, Charles Chen "
format: html
editor: visual
---

## Introduction

Danceable songs are not only popular but often achieve significant success among listeners due to their upbeat nature and frequent use in curated playlists. For this reason, we analyze how Spotify quantifies user data and predicts what users are likely to enjoy by recommending different types of songs based on their listening history, with the broader goal of better understanding how music streaming algorithms operate and what types of variables Spotify itself prioritizes. Our analysis explores the factors that predict song danceability using a dataset of 114,000 Spotify tracks across 114 different genres. Danceability is a continuous variable ranging from 0 to 1, describing how suitable a track is for dancing based on musical elements such as tempo, rhythm stability, beat strength, and overall regularity.

We address the following research questions:

Our research questions generally focus on the exploration of predictors of danceability since we wanted to understand why Spotify would include this as a metric for their algorithm.

1.  **Simple Linear Regression**: Does song tempo predict danceability?
2.  **Multiple Linear Regression**: What combination of predictive features (energy, valence, tempo, etc.) best predicts danceability?
3.  **Categorical Predictors**: Do certain genres produce more danceable music than others?
    1.  Sub-Question: Is there a difference in danceability between explicit tracks and clean tracks?
4.  **Genre-Specific Analysis**: Do "dance" genre songs have different danceability predictors than other genres?

```{r setup, message=FALSE, warning=FALSE}
pacman::p_load("tidyverse", "broom", "knitr", "leaps")

# getting data
music <- read_csv("dataset.csv", show_col_types = FALSE)

```

## Exploratory Data Analysis

```{r}
summary(music$danceability)

# Histogram of danceability
ggplot(music, aes(x = danceability)) +
    geom_histogram(fill = "steelblue", color = "white") +
    labs(title = "Danceability Distribution", x = "Danceability", y = "Density") +
    theme_minimal()
```

### Danceability by Genre

```{r}
# Count of genres
genre_counts <- n_distinct(music$track_genre)
cat("Number of Genres: ", genre_counts)

# Average danceability by genre
genre_means <- music %>%
    group_by(track_genre) %>%
    summarise(mean_danceability = mean(danceability), n = n()) %>%
    arrange(desc(mean_danceability))

# 10 most danceable genres
kable(head(genre_means, 10), caption = "10 Most Danceable Genres", digits = 3)

# 10 least danceable genres
kable(tail(genre_means, 10), caption = "10 Least Danceable Genres", digits = 3)

# Visualize top and bottom genres
genre_extreme <- bind_rows(head(genre_means, 10) %>% mutate(category = "Most Danceable"), tail(genre_means, 10) %>% mutate(category = "Least Danceable"))

ggplot(genre_extreme, aes(x = reorder(track_genre, mean_danceability), y = mean_danceability, fill = category)) +
    geom_col() +
    coord_flip() +
    labs(title = "Danceability Extremes by Genre", x = "Genre",y = "Mean Danceability", fill = "") +
    theme_minimal() +
    scale_fill_manual(values = c("Most Danceable" = "darkgreen", "Least Danceable" = "darkred"))
```

### Variable Correlations

```{r}
# Selecting ALL numeric variables for correlation analysis
numeric_vars <- music %>%
    select(
        danceability, popularity, duration_ms, energy, key, loudness,
        mode, speechiness, acousticness, instrumentalness, liveness,
        valence, tempo, time_signature
    )

# Correlation with danceability
cor_with_dance <- cor(numeric_vars, use = "complete.obs")[, "danceability"]
cor_with_dance <- sort(cor_with_dance, decreasing = TRUE)

kable(data.frame(Variable = names(cor_with_dance), Correlation = cor_with_dance), 
      digits = 3, caption = "Correlations with Danceability (All Variables)")

# Sample scatter plot - customize variables as needed
plot(music$valence, music$danceability, 
     main = "Valence vs Danceability", 
     xlab = "Valence", 
     ylab = "Danceability")
abline(lm(danceability ~ valence, data = music), col = "red", lwd = 2)
```

## Question 1: Simple Linear Regression - Does Valence Predict Danceability?

```{r}
# Fitting first reg model
model1 <- lm(danceability ~ valence, data = music)
summary(model1)

# Visualization
ggplot(music, aes(x = tempo, y = valence)) +
    geom_point(alpha = 0.1, color = "steelblue") +
    geom_smooth(method = "lm", color = "red", se = TRUE) +
    labs(
        title = "Valence vs Danceability",
        x = "Valence",
        y = "Danceability"
    ) +
    theme_minimal()

# Model diagnostics
par(mfrow = c(2, 2))
plot(model1)
par(mfrow = c(1, 1))
```

## Question 2: Forward Stepwise Selection

Before we get to fitting a multiple regression model, we use forward stepwise selection to identify which predictors are most important for predicting danceability.

```{r}
# Subsetting to exclude ID variables and genre
music_subset <- music %>%
    select(
        danceability, popularity, duration_ms, energy, key, loudness,
        mode, speechiness, acousticness, instrumentalness, liveness,
        valence, tempo, time_signature
    )

# Forward stepwise selection
regfit.fwd <- regsubsets(danceability ~ .,
    data = music_subset,
    nvmax = 13,
    method = "forward"
)

reg.summary <- summary(regfit.fwd)

# Ploting the selection criteria
par(mfrow = c(2, 2))

# RSS plot - NOT USEFUL
plot(reg.summary$rss, xlab = "Number of Variables", ylab = "RSS (not useful)", type = "o")

# Adjusted R² plot (maximize)
plot(reg.summary$adjr2, xlab = "Number of Variables", ylab = "Adjusted R²", type = "o")
max_adjr2 <- which.max(reg.summary$adjr2)
points(max_adjr2, reg.summary$adjr2[max_adjr2], col = "red", cex = 2, pch = 20)
text(max_adjr2, reg.summary$adjr2[max_adjr2],
    labels = paste("Best:", max_adjr2), pos = 3, col = "red"
)

# AIC criterion (Cp) to minimize
plot(reg.summary$cp, xlab = "Number of Variables", ylab = "Cp", type = "o")
min_cp <- which.min(reg.summary$cp)
points(min_cp, reg.summary$cp[min_cp], col = "red", cex = 2, pch = 20)
abline(a = 1, b = 1, lty = 2) # Ideal line where Cp = p
text(min_cp, reg.summary$cp[min_cp],
    labels = paste("Best:", min_cp), pos = 3, col = "red"
)

# BIC criterion to minimize
plot(reg.summary$bic, xlab = "Number of Variables", ylab = "BIC", type = "o")
min_bic <- which.min(reg.summary$bic)
points(min_bic, reg.summary$bic[min_bic], col = "red", cex = 2, pch = 20)
text(min_bic, reg.summary$bic[min_bic],
    labels = paste("Best:", min_bic), pos = 3, col = "red"
)

#par(mfrow = c(1, 1))

# Showing the variables selected for the best models
#cat("\nBest model by Adjusted R² (", max_adjr2, "variables):\n")
#cat(names(coef(regfit.fwd, max_adjr2))[-1], sep = ", ")

#cat("\n\nBest model by Cp (", min_cp, "variables):\n")
#cat(names(coef(regfit.fwd, min_cp))[-1], sep = ", ")

#cat("\n\nBest model by BIC (", min_bic, "variables):\n")
#cat(names(coef(regfit.fwd, min_bic))[-1], sep = ", ")

# Display coefficient plot for best BIC model
#plot(regfit.fwd, scale = "bic", main = "Variable Selection by BIC")

```

**Interpretation**:

-   **Adjusted R²** suggests using `r max_adjr2` variables (maximizes explained variance)
-   **Cp (AIC)** suggests using `r min_cp` variables (balances fit and complexity)
-   **BIC** suggests using `r min_bic` variables (more conservative, penalizes complexity more)

BIC is generally preferred when we want a more parsimonious model. The BIC-selected model includes: `r paste(names(coef(regfit.fwd, min_bic))[-1], collapse = ", ")`.

## Question 3: Multiple Linear Regression (BIC-Selected Model)

Based on the forward stepwise selection using BIC, we'll now fit the optimal multiple regression model.

```{r}
# Get the variables selected by BIC
best_vars <- names(coef(regfit.fwd, min_bic))[-1]

# Create formula for the best model
formula_str <- paste("danceability ~", paste(best_vars, collapse = " + "))
best_formula <- as.formula(formula_str)

# Fit the BIC-selected model
model2 <- lm(best_formula, data = music_subset)
summary(model2)

# Tidy output
tidy(model2) %>% kable(digits = 4, caption = "BIC-Selected Multiple Regression Model")

# Also fit a full model for comparison
model_full <- lm(
    danceability ~ popularity + duration_ms + energy + key + loudness +
        mode + speechiness + acousticness + instrumentalness + liveness +
        valence + tempo + time_signature,
    data = music_subset
)

# Model comparison
glance(model1) %>%
    bind_rows(glance(model2)) %>%
    bind_rows(glance(model_full)) %>%
    mutate(model = c(
        "Model 1: Tempo only",
        paste0("Model 2: BIC-selected (", min_bic, " vars)"),
        "Model Full: All predictors"
    )) %>%
    select(model, r.squared, adj.r.squared, AIC, BIC) %>%
    kable(digits = 4, caption = "Model Comparison")

# Diagnostic plots for the BIC-selected model
par(mfrow = c(2, 2))
plot(model2)
par(mfrow = c(1, 1))
```

**Interpretation**: The BIC-selected model with `r min_bic` predictors has an R² of `r round(summary(model2)$r.squared, 4)`, explaining `r round(summary(model2)$r.squared * 100, 2)`% of variance in danceability. This is comparable to the full model (R² = `r round(summary(model_full)$r.squared, 4)`) but with fewer predictors, making it more interpretable and less prone to overfitting.

The most important predictors in the BIC-selected model are:

```{r}
# Display coefficients with confidence intervals
coef_summary <- tidy(model2, conf.int = TRUE) %>%
    filter(term != "(Intercept)") %>%
    arrange(desc(abs(estimate)))

kable(coef_summary,
    digits = 4,
    caption = "Predictors Ranked by Effect Size (Absolute Value)"
)

# Visualize coefficients
ggplot(coef_summary, aes(x = reorder(term, estimate), y = estimate)) +
    geom_point(size = 3, color = "steelblue") +
    geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
    coord_flip() +
    labs(
        title = "Coefficient Estimates with 95% Confidence Intervals",
        x = "Predictor",
        y = "Coefficient Estimate"
    ) +
    theme_minimal()
```

## Question 4: Genre Differences (ANOVA)

```{r}
# ANOVA to test if genres differ in danceability
model3 <- lm(danceability ~ track_genre, data = music)
anova_results <- anova(model3)
print(anova_results)

# Effect size
eta_squared <- anova_results$`Sum Sq`[1] / sum(anova_results$`Sum Sq`)
cat("\nEta-squared (effect size):", round(eta_squared, 4))

# Boxplot of danceability by selected genres
selected_genres <- c(
    "hip-hop", "reggaeton", "classical", "opera",
    "sleep", "rock", "pop", "electronic"
)

music %>%
    filter(track_genre %in% selected_genres) %>%
    ggplot(aes(x = reorder(track_genre, danceability), y = danceability, fill = track_genre)) +
    geom_boxplot() +
    coord_flip() +
    labs(
        title = "Danceability Distribution by Selected Genres",
        x = "Genre",
        y = "Danceability"
    ) +
    theme_minimal() +
    theme(legend.position = "none")
```

**Interpretation**: There are statistically significant differences in danceability across genres (F = `r round(anova_results$'F value'[1], 2)`, p \< 0.001). Genre explains approximately `r round(eta_squared * 100, 2)`% of the variance in danceability.

## Question 5: Genre-Specific Analysis - Dance vs. Non-Dance Genres

```{r}
# Create dance genre category
dance_genres <- c(
    "dance", "dancehall", "edm", "house", "techno",
    "detroit-techno", "chicago-house", "minimal-techno"
)

music <- music %>%
    mutate(is_dance_genre = ifelse(track_genre %in% dance_genres, "Dance", "Other"))

# Compare means
music %>%
    group_by(is_dance_genre) %>%
    summarise(
        mean_danceability = mean(danceability),
        sd_danceability = sd(danceability),
        n = n()
    ) %>%
    kable(digits = 3, caption = "Danceability: Dance vs Other Genres")

# T-test
t_test_result <- t.test(danceability ~ is_dance_genre, data = music)
print(t_test_result)

# Separate regression models for dance vs non-dance using BIC-selected variables
# Use the same predictors from the BIC model for consistency
model_dance <- lm(best_formula,
    data = music_subset %>%
        filter(music$is_dance_genre == "Dance")
)

model_other <- lm(best_formula,
    data = music_subset %>%
        filter(music$is_dance_genre == "Other")
)

# Compare coefficients
comparison <- bind_rows(
    tidy(model_dance) %>% mutate(group = "Dance Genres"),
    tidy(model_other) %>% mutate(group = "Other Genres")
) %>%
    select(group, term, estimate, p.value)

kable(comparison, digits = 4, caption = "Regression Coefficients: Dance vs Other Genres")

# Visualize coefficient differences
comparison %>%
    filter(term != "(Intercept)") %>%
    ggplot(aes(x = term, y = estimate, fill = group)) +
    geom_col(position = "dodge") +
    labs(
        title = "Predictor Coefficients: Dance vs Other Genres",
        x = "Predictor",
        y = "Coefficient Estimate",
        fill = "Genre Category"
    ) +
    theme_minimal() +
    coord_flip()

# Model fit comparison
bind_rows(
    glance(model_dance) %>% mutate(group = "Dance Genres"),
    glance(model_other) %>% mutate(group = "Other Genres")
) %>%
    select(group, r.squared, adj.r.squared, AIC) %>%
    kable(digits = 4, caption = "Model Fit: Dance vs Other Genres")
```

**Interpretation**: Dance genres have significantly higher danceability (mean difference = `r round(t_test_result$estimate[1] - t_test_result$estimate[2], 3)`, p \< 0.001). However, the predictors of danceability differ between dance and non-dance genres. For dance genres, the model explains `r round(summary(model_dance)$r.squared * 100, 2)`% of variance, while for other genres it explains `r round(summary(model_other)$r.squared * 100, 2)`%. This suggests that what makes a song danceable may depend on the genre context.

## Data Quality Check: Duplicate Songs Analysis

Before finalizing our conclusions, we should examine whether there are duplicate songs in the dataset that might be inflating our sample size or biasing our results.

```{r}
# Check for duplicates based on track_name and artists
music <- music %>%
    mutate(song_id = paste(track_name, artists, sep = " - "))

# Count duplicates
duplicate_summary <- music %>%
    group_by(song_id) %>%
    summarise(
        n_occurrences = n(),
        track_name = first(track_name),
        artists = first(artists),
        genres = paste(unique(track_genre), collapse = ", ")
    ) %>%
    arrange(desc(n_occurrences))

# Summary statistics
total_songs <- nrow(music)
unique_songs <- n_distinct(music$song_id)
duplicated_songs <- sum(duplicate_summary$n_occurrences > 1)
total_duplicates <- sum(duplicate_summary$n_occurrences[duplicate_summary$n_occurrences > 1])

cat("Total observations:", total_songs, "\n")
cat("Unique songs:", unique_songs, "\n")
cat("Songs that appear multiple times:", duplicated_songs, "\n")
cat("Total duplicate observations:", total_duplicates - duplicated_songs, "\n")
cat("Percentage of duplicates:", round((total_duplicates - duplicated_songs) / total_songs * 100, 2), "%\n")

# Show most duplicated songs
kable(head(duplicate_summary %>% filter(n_occurrences > 1), 15),
    caption = "Most Frequently Duplicated Songs",
    digits = 0
)

# Distribution of duplication
ggplot(
    duplicate_summary %>% filter(n_occurrences > 1),
    aes(x = n_occurrences)
) +
    geom_histogram(binwidth = 1, fill = "coral", color = "white") +
    labs(
        title = "Distribution of Song Duplications",
        x = "Number of Times Song Appears",
        y = "Count of Songs"
    ) +
    theme_minimal()
```

### Analysis with Duplicates Removed

Now let's re-run our key analyses with only unique songs to see if our conclusions change.

```{r}
# Create deduplicated dataset - keep first occurrence of each song
music_unique <- music %>%
    distinct(song_id, .keep_all = TRUE)

cat("Original dataset size:", nrow(music), "\n")
cat("Deduplicated dataset size:", nrow(music_unique), "\n")
cat("Reduction:", nrow(music) - nrow(music_unique), "observations\n")

# Re-run simple linear regression
model1_unique <- lm(danceability ~ tempo, data = music_unique)

# Re-run multiple regression
model2_unique <- lm(danceability ~ energy + valence + tempo + loudness + speechiness + acousticness,
    data = music_unique
)

# Re-run genre ANOVA
model3_unique <- lm(danceability ~ track_genre, data = music_unique)
anova_results_unique <- anova(model3_unique)
eta_squared_unique <- anova_results_unique$`Sum Sq`[1] / sum(anova_results_unique$`Sum Sq`)

# Re-run dance vs other analysis
music_unique <- music_unique %>%
    mutate(is_dance_genre = ifelse(track_genre %in% dance_genres, "Dance", "Other"))

model_dance_unique <- lm(danceability ~ energy + valence + tempo + loudness,
    data = music_unique %>% filter(is_dance_genre == "Dance")
)

model_other_unique <- lm(danceability ~ energy + valence + tempo + loudness,
    data = music_unique %>% filter(is_dance_genre == "Other")
)

# Comparison table
comparison_table <- data.frame(
    Analysis = c(
        "Simple Regression (Tempo)", "Simple Regression (Tempo)",
        "Multiple Regression", "Multiple Regression",
        "Genre ANOVA (Eta²)", "Genre ANOVA (Eta²)",
        "Dance Genres Model", "Dance Genres Model",
        "Other Genres Model", "Other Genres Model"
    ),
    Dataset = rep(c("With Duplicates", "Deduplicated"), 5),
    R_squared = c(
        summary(model1)$r.squared, summary(model1_unique)$r.squared,
        summary(model2)$r.squared, summary(model2_unique)$r.squared,
        eta_squared, eta_squared_unique,
        summary(model_dance)$r.squared, summary(model_dance_unique)$r.squared,
        summary(model_other)$r.squared, summary(model_other_unique)$r.squared
    )
)

kable(comparison_table,
    digits = 4,
    caption = "Model Performance: Original vs Deduplicated Data"
)

# Coefficient comparison for multiple regression
coef_comparison <- bind_rows(
    tidy(model2) %>% mutate(dataset = "With Duplicates"),
    tidy(model2_unique) %>% mutate(dataset = "Deduplicated")
) %>%
    select(dataset, term, estimate, std.error, p.value)

kable(coef_comparison,
    digits = 4,
    caption = "Multiple Regression Coefficients: Original vs Deduplicated"
)

# Visualize coefficient differences
coef_comparison %>%
    filter(term != "(Intercept)") %>%
    ggplot(aes(x = term, y = estimate, fill = dataset)) +
    geom_col(position = "dodge") +
    labs(
        title = "Coefficient Comparison: Original vs Deduplicated Data",
        x = "Predictor",
        y = "Coefficient Estimate",
        fill = "Dataset"
    ) +
    theme_minimal() +
    coord_flip() +
    scale_fill_manual(values = c(
        "With Duplicates" = "steelblue",
        "Deduplicated" = "darkgreen"
    ))
```

**Interpretation**: After removing `r nrow(music) - nrow(music_unique)` duplicate observations, our sample size decreased from `r nrow(music)` to `r nrow(music_unique)` unique songs. The key findings:

-   **Model performance remained stable**: R² values changed minimally across all models
-   **Coefficient estimates are similar**: The direction and magnitude of relationships are consistent
-   **Statistical significance preserved**: All main effects remain significant
-   **Conclusion validity**: The presence of duplicates did not substantially bias our results, suggesting our conclusions are robust

## Conclusions

1.  **Tempo alone is a weak predictor** of danceability (R² ≈ `r round(summary(model1)$r.squared, 3)`), suggesting the relationship is more complex.

2.  **Multiple predictors substantially improve prediction**: Valence (musical positivity), loudness, and acousticness are stronger predictors than tempo. The full model explains about `r round(summary(model2)$r.squared * 100, 1)`% of variance.

3.  **Genre matters significantly**: Some genres (hip-hop, reggaeton, chicago-house) are inherently more danceable than others (sleep, grindcore, opera).

4.  **Different genres have different danceability drivers**: The factors that predict danceability in dance-oriented genres differ from those in other genres, suggesting genre-specific models may be more appropriate for prediction.

## Future Directions

-   Investigate non-linear relationships (e.g., quadratic tempo effects)
-   Explore interaction terms (e.g., energy × genre)
-   Consider additional categorical predictors like time signature and mode
-   Examine whether explicit content affects danceability differently across genres
